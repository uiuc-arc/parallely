package main

import (
  "math"
  "errors"
  "io"
  "io/ioutil"
  "os"
  "regexp"
  "strconv"
  "fmt"
  "time"
  "diesel"
)

const numWorkers = 10
const WorkPerThread = 100
const totalSamples = numWorkers*WorkPerThread
var X [totalSamples]float64
var Y [totalSamples]float64

var Alpha float64
var Beta  float64

const (
  // single whitespace character
  ws = "[ \n\r\t\v\f]"
  // isolated comment
  cmt = "#[^\n\r]*"
  // comment sub expression
  cmts = "(" + ws + "*" + cmt + "[\n\r])"
  // number with leading comments
  num = "(" + cmts + "+" + ws + "*|" + ws + "+)([0-9]+)"
)

var rxHeader = regexp.MustCompile("^P6" + num + num + num + "(" + cmts + "*" + ")" + ws)
var rxComment = regexp.MustCompile(cmt)

func convertToFloat(x int) float64 {
  return float64(x)
}

__GLOBAL_DECS__

__FUNC_DECS__

func main() {
  // rand.Seed(time.Now().UTC().UnixNano())
  rand.Seed(12345) // deterministic seed for reproducibility

  fmt.Println("Starting main thread");
  NumThreads = __NUM_THREADS__;
	
  diesel.InitChannels(__NUM_THREADS__);

  alpha := rand.NormFloat64()
  beta  := rand.NormFloat64()

  for i := 0; i < totalSamples; i++ {
    X[i] = rand.NormFloat64()*100
    Y[i] = alpha + beta*(X[i]+rand.NormFloat64()) // add some error
  }

  startTime := time.Now()
  __START__THREADS__

  fmt.Println("Main thread waiting for others to finish");  
  diesel.Wg.Wait()

  end := time.Now()
  elapsed := end.Sub(startTime)
  fmt.Println("Elapsed time :", elapsed.Nanoseconds())

  fmt.Println('Alpha:", Alpha, "Beta:", Beta)
}
