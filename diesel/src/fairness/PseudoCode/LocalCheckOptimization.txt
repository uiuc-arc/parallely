Fairness: (same benchmark in both Aws and Armando's paper)
------------------------------------------------------------
Master{
	float [3][10000] PeopleArray = [[1,23,5],[0,2,4],.....]
	int i =0
	for x : [PID1...PID10]{
		send(PeopleArray[1:3][i*1000:i*1000+1000])
		i += 1
	}


}

Worker{
	PeopleArray = receive()
	int Males = 0
	int Females = 0

	float delta = 0.99 //can be whatever threshold we want (but it will necessarily be tighter on each processor)
	float epsilon = 0 //doesn't matter what we initialize this too since it will be overwritten

	dynamic float MaleHireProb = 0 //doesn't matter what we initialize this too since it will be overwritten
        track(MaleHireProb,0,0)

	dynamic float FemaleHireProb = 0 //doesn't matter what we initialize this too since it will be overwritten
	track(FemaleHireProb,0,0)

	dynamic float Ratio = 0 //doesn't matter what we initialize this too since it will be overwritten
	track(Ratio,0,0)

	//a person is a 3tuple consisting of (gender,college_rank,years_exp)...we can have arrays of arrays as valid types right?
	for person in PeopleArray:

	    int Decision = HiringFunc(person)

	    if isMale(person){
		Males += 1
		HiredMales += Decision
		MaleHireProb = (float) HiredMales / Males 

		//manually set updated epsilon after each iteration (abusing the track statement, I know...)
		eps = f(Males,delta/2)   //f(n,delta) = sqrt(1/2n * log*2/delta))
		track(MaleHireProb,eps,delta/2)	
	    }
	    else {
		Females += 1
		HiredFemales += Decision
	        FemaleHireProb = (float) HiredFemales / Females

		//manually set updated epsilon after each iteration (abusing the track statement, I know...)
		eps = f(Females,delta/2)
		track(FemaleHireProb,eps,delta/2)
            }

	
	    //since ratio is an arithmetic combination of two dynamically tracked vars
	    //it will have it's own dynamically tracked eps and delta
	    Ratio = MaleHireProbs/FemaleHireProbs


	  //at the end we can either check this locally on each processor using DynCheck(Ratio)
	  //or have each worker send their Ratio to master and *then* check.
          

	  // Ratio.value - Ratio.epsilon > 0.8  <==> Ratio.epsilon < Ratio.value - 0.8
	  dyn_check(Ratio,Ratio-0.8,delta); //here we check locally on each processor
}



Differential Privacy benchmark from PAssert paper
-------------------------------------------
Master{
	float [10000] LocationsArray = [20,23,19,...]
	int i =0
	for x : [PID1...PID10]{
		send(LocationsArray[i*1000:i*1000+1000])
		i += 1
	}
}

Worker{
	LocationsArray = receive()
	int n = 0
	int sum =0 
        float delta = 0.99 //can be whatever threshold we want (but it will necessarily be tighter on each processor)

	//Equivalent to @DynFloat assertionProb ={val:0,eps:0,delta:0}
	dynamic float assertionProb = 0 	//again, it doesn't matter what we initialize to since it will be overwritten each sample.
        track(assertionProb,0,0);

	for loc in LocationsArray
	    n += 1
	    float noisy = AddNoise(loc)
	    bool I = abs(loc-noisy) < 10	//the PAssert boolean expression

	    sum += (int)I
	    assertionProb = sum/n

	    //manually set eps and delta
	    eps= f(n, delta)
	    track(assertionProb,eps,delta)

	   //can either check assertionProb locally on each processor using DynCheck(assertionProb, threshold)
	   //or have each worker send it back to master	   

	   //assertionProb.value - assertionProb.eps > 0.5 <==> assertionProb.eps < assertionProb.value - 0.5 
	   dyn_check(assertionProb,assertionProb-0.5,delta)
}
