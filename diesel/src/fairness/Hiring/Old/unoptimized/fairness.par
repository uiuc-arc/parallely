/*
 Specification is:
 E[Hire|Male]/E[Hire|Female] > 0.8
*/

 
Q = {1,2,3,4,5,6,7,8,9,10}; //processes

0:[

//precise int [10000] genders;
//precise float64 [10000] college_ranks;
//precise float64 [10000] years_exp
dynamic float32 ratio;
dynamic float32 ratio_sum;

track(ratio_sum,0,0);

for q in Q do {

   send(q,precise int[],genders);
   send(q,precise int[],college_rank);
   send(q,precise int[],years_exp);
   
}


for q in Q do {
   ratio = dynrecieve(q,dynamic float32);
   ratio_sum = ratio_sum + ratio

}

ratio_sum = (1./10.) * ratio_sum;
check(ratio_sum,ratio_sum-0.8,2*delta);


]

||

q in Q:[

	precise int [100000/10] genders;
	precise float64 [100000/10] college_ranks;
	precise float64 [100000/10] years_exp;
	precise int males = 0;
	precise int females = 0;
	precise int hired_males = 0;
	precise int hired_females = 0;
	precise int hired;
	precise int i;
	precise float delta =0.01;
	precise float epsilon;
	dynamic float32 male_hired_mean;
	dynamic float32 female_hired_mean;
	dynamic float32 ratio;

	repeat 10000 {
		hired = f(college_ranks[i],years_exp[i]);	//this function could be expanded out
		if (gender > 0){
			males = males + 1;
			if (hired > 0){
				hired_males = hired_males + 1;
			}
			else {
				skip;
			}
		}
		else {
			females = females + 1;
			if (hired > 0){
				hired_females = hired_females + 1;
			}
			else {
				skip;
			}
		}
	}
	epsilon = sqrt((3/5 * log(log(i+1)/log(11/10))+(5/9)*log(24/delta))/i)

	male_hired_mean	= track(hired_males/males,delta,epsilon)
	female_hired_mean = track(hired_females/females,delta,epsilon)
	
	ratio = male_hired_mean/female_hired_mean;		//runtime performs reliability and accuracy on ratio 
	dynsend(0,dynamic float32, ratio);			//sends the ratio (which is dynamic type)
]






