package main

import (
  "fmt"
  "math"
  "math/rand"
  "time"
  "diesel"
)

const blockDim = 64
const workers = 8
const BlocksPerWorker = __BLOCKSPERWORKER__

var BestBlock, BestSSD int

var refBlock, searchBlocks []int

const (
  // single whitespace character
  ws = "[ \n\r\t\v\f]"
  // isolated comment
  cmt = "#[^\n\r]*"
  // comment sub expression
  cmts = "(" + ws + "*" + cmt + "[\n\r])"
  // number with leading comments
  num = "(" + cmts + "+" + ws + "*|" + ws + "+)([0-9]+)"
)

func calcSSD(block int) int {
  ssd := 0
  for i := 0; i < blockDim; i++ {
    diff := refBlock[i] - searchBlocks[block*blockDim+i]
    ssd += diff*diff
  }
  return ssd
}

func argMin(list []int) int {
  min := list[0]
  arg := 0
  for i, val := range list {
    if val < min {
      min = val
      arg = i
    }
  }
  return arg
}

func argMinDynMapCalc(dynMap []diesel.ProbInterval) diesel.ProbInterval {
  rel := float32(1.0)
  for _, pi := range dynMap {
    rel *= pi.Reliability
  }
  return diesel.ProbInterval{rel, 0.0}
}

__GLOBAL_DECS__

__FUNC_DECS__

func main() {
  // rand.Seed(time.Now().UTC().UnixNano())
  seed := int64(12345)
  rand.Seed(seed) // deterministic seed for reproducibility

  refBlock = make([]int, blockDim)
  arrayDim := blockDim*BlocksPerWorker*workers
  searchBlocks = make([]int, arrayDim)

  fmt.Println("Generating blocks using random seed",math.Abs(float64(seed)))

  for i := 0; i < blockDim; i++ {
    refBlock[i] = rand.Intn(256)
  }
  for i := 0; i < arrayDim; i++ {
    searchBlocks[i] = rand.Intn(256)
  }

  fmt.Println("Starting program");
	
  diesel.InitChannels(__NUM_THREADS__);

  startTime := time.Now()
  __START__THREADS__

  fmt.Println("Main thread waiting for others to finish");  
  diesel.Wg.Wait()

  end := time.Now()
  elapsed := end.Sub(startTime)
  fmt.Println("Elapsed time :", elapsed.Nanoseconds())

  fmt.Println(BestBlock, BestSSD)
}
