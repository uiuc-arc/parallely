package main

import "fmt"
import "parallely"
import "time"
import "os"
import  "io/ioutil"
import  "strings"
import  "strconv"

var Num_threads int
var Edges []int
var Inlinks []int
var Outlinks []int
var DistGlobal [62586]int
var Num_nodes int
var Num_edges int
var NodesPerThread int

func max(x, y int) int {
	if x > y {
		return x;
	} else {
		return y;
	}
}

func min(x, y int) int {
	if x < y {
		return x;
	} else {
		return y;
	}
}

func convertToFloat(x int) float64 {
	return float64(x)
}
	
var Q = []int {1,2,3,4,5,6,7,8,9,10};


func func_0() {
  defer parallely.Wg.Done();
  var DynMap [62587]float64;
  _ = DynMap;
  var distance [62586]int;
parallely.InitDynArray(0, 62586, DynMap[:]);
var newDist int;
DynMap[62586] = 1;
var mystart int;
var myend int;
var i int;
var j int;
var lastthread int;
var mysize int;
distance=DistGlobal;
parallely.InitDynArray(0, 62586, DynMap[:]);
i = 0;
for _, q := range(Q) {
 mystart = i*NodesPerThread;
myend = (i+1)*NodesPerThread;
lastthread = parallely.ConvBool(i==Num_threads);
if lastthread != 0 {
 myend = Num_nodes;
 }
parallely.SendIntArray(Edges[:], 0, q);
parallely.SendIntArray(Inlinks[:], 0, q);
parallely.SendIntArray(Outlinks[:], 0, q);
parallely.SendInt(mystart, 0, q);
parallely.SendInt(myend, 0, q);
i = i+1;
 }
for __temp_0 := 0; __temp_0 < 10; __temp_0++ {
 for _, q := range(Q) {
 parallely.SendDynIntArrayO1(distance[:], 0, q, DynMap[:], 0);
 }
i = 0;
for _, q := range(Q) {
 mystart = i*NodesPerThread;
myend = (i+1)*NodesPerThread;
lastthread = parallely.ConvBool(i==Num_threads);
if lastthread != 0 {
 myend = Num_nodes;
 }
mysize = myend-mystart;
j = 0;
for __temp_1 := 0; __temp_1 < mysize; __temp_1++ {
 parallely.ReceiveInt(&newDist, 0, q);
my_chan_index := q * parallely.Numprocesses + 0;
__temp_rec_val := <- parallely.DynamicChannelMap[my_chan_index];
DynMap[62586] = __temp_rec_val;
_temp_index_1 := mystart+j;
distance[_temp_index_1]=newDist;
DynMap[0 + _temp_index_1] = DynMap[62586];
j = j+1;
 }
i = i+1;
 }
 }

fmt.Println("----------------------------");

fmt.Println("Spec checkarray(distance, 0.99): ", parallely.CheckArray(0, 0.99, 62586, DynMap[:]));

fmt.Println("----------------------------");

DistGlobal=distance;
parallely.CopyDynArray(0, 0, 62586, DynMap[:]);

  fmt.Println("Ending thread : ", 0);
}
func func_Q(tid int) {
  defer parallely.Wg.Done();
  var DynMap [72590]float64;
  _ = DynMap;
  q := tid;
var edges [62586000]int;
var inlinks []int;
 inlinks=make([]int, Num_nodes);
var outlinks []int;
 outlinks=make([]int, Num_nodes);
var distances [62586]int;
parallely.InitDynArray(0, 62586, DynMap[:]);
var distance int;
DynMap[62586] = 1;
var newDistance [10000]int;
parallely.InitDynArray(62587, 10000, DynMap[:]);
var condition int;
DynMap[72587] = 1;
var inlink int;
var neighbor int;
var nodeInlinks int;
var i int;
var mystart int;
var myend int;
var cur int;
var temp int;
DynMap[72588] = 1;
var temp0 int;
DynMap[72589] = 1;
var mysize int;
parallely.ReceiveIntArray(edges[:], tid, 0);
parallely.ReceiveIntArray(inlinks[:], tid, 0);
parallely.ReceiveIntArray(outlinks[:], tid, 0);
parallely.ReceiveInt(&mystart, tid, 0);
parallely.ReceiveInt(&myend, tid, 0);
for __temp_2 := 0; __temp_2 < 10; __temp_2++ {
 parallely.ReceiveDynIntArrayO1(distances[:], tid, 0, DynMap[:], 0);
mysize = myend-mystart;
i = 0;
for __temp_3 := 0; __temp_3 < mysize; __temp_3++ {
 cur = mystart+i;
_temp_index_1 := cur;
nodeInlinks=inlinks[_temp_index_1];
_temp_index_2 := cur;
distance=distances[_temp_index_2];
DynMap[62586] = DynMap[0 + _temp_index_2];
inlink = 0;
for __temp_4 := 0; __temp_4 < nodeInlinks; __temp_4++ {
 _temp_index_3 := cur*1000+inlink;
neighbor=edges[_temp_index_3];
_temp_index_4 := neighbor;
temp=distances[_temp_index_4];
DynMap[72588] = DynMap[0 + _temp_index_4];
condition = parallely.ConvBool(distance>temp+1);
DynMap[72587] = parallely.Max(0.0, DynMap[62586] + DynMap[72588] - float64(1));
temp_bool_5:= condition; if temp_bool_5 != 0 { distance  = temp } else { distance = distance };
if temp_bool_5 != 0 {DynMap[72587]  = DynMap[62586] + DynMap[62586] - 1.0} else { DynMap[72587] = DynMap[72588 ] + DynMap[62586] - 1.0};
inlink = inlink+1;
 }
_temp_index_6 := i;
newDistance[_temp_index_6]=distance;
DynMap[62587 + _temp_index_6] = DynMap[62586];
i = i+1;
 }
i = 0;
for __temp_5 := 0; __temp_5 < mysize; __temp_5++ {
 _temp_index_7 := i;
temp0=newDistance[_temp_index_7];
DynMap[72589] = DynMap[62587 + _temp_index_7];
temp = parallely.Randchoice(float32(0.999999), temp0, -1);
DynMap[72588] = DynMap[72589] * 0.999999;
parallely.SendInt(temp, tid, 0);
parallely.SendDynVal(DynMap[72588], tid, 0);
i = i+1;
 }
 }

  fmt.Println("Ending thread : ", q);
}

func main() {
	fmt.Println("Starting main thread");

  Num_threads = 11;
	
	parallely.InitChannels(11);
	
  data_bytes, _ := ioutil.ReadFile("/home/vimuth/projects/parallely/benchmarks/inputs/p2p-Gnutella31.txt")
  Num_nodes = 62586 // strconv.Atoi(os.Args[2])
  Num_edges = Num_nodes * 1000

  fmt.Println("Starting reading the file")
  data_string := string(data_bytes)
  data_str_array := strings.Split(data_string, "\n")

  fmt.Println("Setting up the data structures")
  Edges = make([]int, 62586000)
  Inlinks = make([]int, Num_nodes)
  Outlinks = make([]int, Num_nodes)

  for i := range Inlinks{
    Inlinks[i] = 0
    Outlinks[i] = 0
    DistGlobal[i] = 0
  }
  DistGlobal[0] = 1

  NodesPerThread = Num_nodes/Num_threads;

  fmt.Println("Populating the data structures")
  for i := 1; i<len(data_str_array)-1 ; i++ {
    elements := strings.Fields(data_str_array[i])
    index1, _ := strconv.Atoi(elements[0])
    index2, _ := strconv.Atoi(elements[1])

    Edges[(index2 * 1000) + Inlinks[index2]] = index1
    Inlinks[index2]++
    Outlinks[index1]++
		// fmt.Println("---------------")
  }

  fmt.Println("Number of worker threads: ", Num_threads);
  fmt.Println("Number of nodes: ", len(DistGlobal));
  fmt.Println("Size of Inlinks: ", len(Inlinks));

  fmt.Println("Starting the iterations")
  startTime := time.Now()

	go func_0();
for _, index := range Q {
go func_Q(index);
}


	fmt.Println("Main thread waiting for others to finish");  
	parallely.Wg.Wait()
  elapsed := time.Since(startTime)

	fmt.Println("Done!");
  fmt.Println("Elapsed time : ", elapsed.Nanoseconds());

  f, _ := os.Create("output.txt")
  defer f.Close()

  for i := range DistGlobal{
    f.WriteString(fmt.Sprintln(DistGlobal[i]))
  }
}
